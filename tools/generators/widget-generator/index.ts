import { Tree, readProjectConfiguration } from '@nrwl/devkit';
import { readdir, readFile } from 'fs/promises';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { format } from 'prettier';

import { DefinitionGenerator } from './definition-generator';
import { toCamelCase } from 'js-convert-case';

export default async function (tree: Tree, schema: any) {
  if (schema.name !== 'widget') {
    throw new Error(
      'We only support use this command for @shukun/widget library.',
    );
  }

  const projectConfiguration = readProjectConfiguration(tree, schema.name);
  new Generate(tree.root, projectConfiguration.root).generate();
}

class Generate {
  private prettierConfig: any;
  private treeRoot: string;
  private projectRoot: string;
  private originFolder: string;
  private targetFolder: string;
  private comment: string;

  constructor(treeRoot: string, projectRoot: string) {
    const text = readFileSync(join(treeRoot, '.prettierrc'), {
      encoding: 'utf-8',
    });
    this.prettierConfig = JSON.parse(text);
    this.treeRoot = treeRoot;
    this.projectRoot = projectRoot;
    this.originFolder = 'definitions';
    this.targetFolder = 'types';
    this.comment =
      '/* eslint-disable */\n/* tslint:disable */\n/**\n* This file was automatically generated by SHUKUN.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run SHUKUN to regenerate this file.\n*/';
  }

  async generate() {
    const dir = await readdir(
      join(this.treeRoot, this.projectRoot, 'src', this.originFolder),
      {
        encoding: 'utf-8',
      },
    );

    const list = dir.filter((item) => item.endsWith('.definition.json'));

    const queue = list.map(async (fileName: string) => {
      const json = readFileSync(
        join(
          this.treeRoot,
          this.projectRoot,
          'src',
          this.originFolder,
          fileName,
        ),
        { encoding: 'utf-8' },
      );

      const input = this.parseJson(json);
      const definitionGenerator = new DefinitionGenerator();
      const output = await definitionGenerator.generate(input);
      const outputWithComments = this.comment + '\n' + output;
      const formatted = format(outputWithComments, {
        parser: 'typescript',
        ...this.prettierConfig,
      });

      const outputFileName =
        fileName.substring(0, fileName.length - '.definition.json'.length) +
        '.definition.ts';

      writeFileSync(
        join(
          this.treeRoot,
          this.projectRoot,
          'src',
          this.targetFolder,
          outputFileName,
        ),
        formatted,
      );

      return outputFileName;
    });

    const fileNames = await Promise.all(queue);

    await this.writeTsIndex(fileNames);

    await this.writeJsonIndex(list);

    console.log('Generate type files successfully.');
  }

  private parseJson(json: string): any {
    return JSON.parse(json);
  }

  private async writeTsIndex(fileNames: string[]) {
    const indexText = fileNames
      .map(
        (fileName) =>
          `export * from './${fileName.substring(
            0,
            fileName.length - '.ts'.length,
          )}';`,
      )
      .join('\n');

    const formatted = format(indexText, {
      parser: 'typescript',
      ...this.prettierConfig,
    });
    writeFileSync(
      join(
        this.treeRoot,
        this.projectRoot,
        'src',
        this.targetFolder,
        'index.ts',
      ),
      formatted,
    );
  }

  private async writeJsonIndex(fileNames: string[]) {
    let imports = `import { WidgetSchema } from '@shukun/schema';\n\n`;
    let outputs = '';

    fileNames.forEach((fileName) => {
      const id = fileName.substring(
        0,
        fileName.length - '.definition.json'.length,
      );
      const name = toCamelCase(id);
      const importName = name + 'DefinitionJson';
      const outputName = name + 'Definition';
      imports += `import ${importName} from './${fileName}';`;
      outputs += `export const ${outputName} = ${importName} as any as WidgetSchema;`;
    });

    const indexText = imports + '\n' + '\n' + outputs;

    const formatted = format(indexText, {
      parser: 'typescript',
      ...this.prettierConfig,
    });
    writeFileSync(
      join(
        this.treeRoot,
        this.projectRoot,
        'src',
        this.originFolder,
        'index.ts',
      ),
      formatted,
    );
  }
}
